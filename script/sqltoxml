#!/usr/bin/perl -w

use XML::Entities;

$auto=0;
&load_data;
&scan_names('pages');
&show_xml('pages');
exit;

# load the data
sub load_data {
  %table_def = ();
  %table_col = ();
  %table_data = ();
  #%tags = ();
  %names = ();
  %name_map = ();
  while (<>) {
    chomp;
    if ($create) {
      if (/^\s*\)/) {
        $create = '';
        next;
      } elsif (/\s*\`([^\`]*)\`\s*/) {
#print STDERR "Def($create) $1\n";
        push(@$coldef, $1);
        $$tdef{$1} = $';
      } else {
print STDERR "CR: $_";
      }
    } elsif (/^CREATE TABLE \`([^\`]*)\`\s*\($/) {
      $create = $1;
#print STDERR "Create:$create\n";
print STDERR "DUP $create\n" if (defined($table_def{$create}));
      $tdef = $table_def{$create} = {};
      $coldef = $table_col{$create} = [];
    } elsif (/^INSERT INTO \`([^\`]*)\` VALUES\s*/) {
      &data($1, $');
    }
  }
}

sub data {
my ($insert, $data) = (shift, shift);
my $rows = $table_data{$insert};
  $table_data{$insert} = $rows = [] unless $rows;
my $pstate = 0; # 0: '' or (), 1: (..) 2: (value3: (value, or (
my $n=0;
  while ($data =~ s/^[\(\),;]|\d+|NULL|'([^'\\]*(\\.[^'\\]*)*)'//) {
    $tok = $1 || $&;
#print STDERR "T[$pstate]$tok:";
    if (!$pstate) {
      if ($tok eq '(') {
        $pstate=2;
        $row = [];
      } else { perror($pstate, $tok); }
    } elsif ($pstate==2) {
      if ($tok !~ /^[\(\),;]$/) { # value
        $pstate=3;
        push(@$row, $tok);
      } else {
        perror($pstate, $tok);
      }
    } elsif ($pstate==3) {
      if ($tok eq ')') {
        $pstate=1;
        push(@$rows, $row);
      } elsif ($tok eq ',') { $pstate=2; }
      else { perror($pstate, $tok); }
    } elsif ($pstate==1) {
      if ($tok eq ',') { $pstate=0; }
      elsif ($tok eq ';') { $pstate=99; }
      else { perror($pstate, $tok); }
    } else { # $pstate = 99
      perror($pstate, $tok);
    }
  }
print STDERR "More[$n]",substr($data,0,40),"\n" if ($data);
  $rows;
}

sub scan_names {
my $table=$_[0];
my $dref = $table_data{$table};
#my ($tot, $n) = (0, 0);

  for my $row (@$dref) {
    my ($ns, $name, $cont) = @$row[1..3];
    next if $ns;
    my $title = scan_pagename($name);

    #$n++;
    #$tot+=length($cont);
    #$g = ($name =~ /^English/) ? 1 :($name =~ /^Fr/) ? 2: 3;
    #$n[$g]++; $tot[$g]+=length($cont);
    #print STDERR "Row($n,$n[$g]:$g) $name:",length($cont),"\n";
  }
}

sub scan_pagename {
my $name = shift;
  $name =~ tr/ /_/;
  #$name =~ s/&/&amp;/g;
  #$name =~ s/\\?"/&quote;/g;
  $title = $name;
  my $name_path = '';
  $title =~ s!^.*/!!;
  $name_path = $&;
  if (defined($names{$name})) {
    if ($names{$name} ne $title) {
      print STDERR "scan_name missmatch: $name: $title :: $names{$name}\n";
    }
  } else { $names{$name} = $title; }
  if (defined($name_map{$title})) {
    if ($name_path) {
      $name_path =~ s!^.*/(.)!$1!;
    } else {
      $name_path = (A..Z)[$auto++] unless $name_path;
    }
    $title .= '_'.substr($name_path,0,3);
    if (defined($name_map{$title})) {
      print STDERR "Dup name: $title: $name :: $name_map{$title}\n";
    } else { $name_map{$title} = $name; }
  } else { $name_map{$title} = $name; }
#print STDERR "Name: $name => $title\n";
  $title;
}

sub show_xml {
my $table=$_[0];
my $dref = $table_data{$table};
#my $colref = $table_col{$table};
my $n=0;
my $tot=0;

  #@$colref;
  print "<deki>\n";
  for my $row (@$dref) {
    next if $$row[1] != 0; # namespace 0 only
    XML::Entities::numify('all',$$row[3]);
    $$row[3] =~ s/\\"/"/g;
    $$row[3] =~ s/\\n/\n/g;
    my $name = &pagename($$row[2]);
    $title = $$row[2];
    $title =~ s/&/&amp;/g;
    $title =~ s/\\?"/&quot;/g;
    $name =~ s/&/&amp;/g;
    $name =~ s/\\?"/&quot;/g;
    print qq!<page title="$title" name="$name">$$row[3]</page>\n!;
  }
  print "</deki>\n";
}

#sub link {
#my ($attrs, $cont) = @_;
#  my %attrs = ();
##print STDERR "Scan for attr[$nlnk]$attrs\n";
#  grep( /\b(\w+)=\s*\\?"(.*?)\\?"/ && ($attrs{$1} = $2),
#      ($attrs =~ /\b\w+=\s*\\?".*?\\?"/g) );
##print STDERR "AA: ",join(", ",(keys %attrs)), "\n";
##for my $a (sort keys %attrs) { print STDERR "A:$a V:$attrs{$a}\n"; }
#  if (defined($attrs{name}) && !defined($attrs{href})) {
#print STDERR "Anchor: $attrs{name}\n";
#    '';
#  } elsif ($attrs{class} =~ /^\s*internal\s*$/) {
#    my $title = &pagename($attrs{title});
#     $res = "[[$title]]";
#print STDERR "Int: $res\n";
#    $res;
#  } elsif ($attrs{class} =~ /^\s*external\s*$/) {
#     $res = ($attrs{href} eq $cont) ? "[[$cont]]" : "[[$attrs{href}|$cont]]";
#print STDERR "Ext: $res\n";
#    $res;
#  } else {
#    $res = '[[Bad link]]';
#grep($res.="$_=>$attrs{$_} ", (sort keys %attrs));
#print STDERR "Bad class: $attrs{class}\n$res\n";
#    $res;
#  }
#}

sub pagename {
my $name = shift;
  $name =~ tr/ /_/;
  #$name =~ s/&/&amp;/g;
  #$name =~ s/\\?"/&quot;/g;
  my $title = $name;
  $title =~ s!^.*/!!;
  my $name_path = $&;
  if (defined($names{$name})) {
    if ($names{$name} ne $title) {
      $name_path =~ s!^.*/(.)!$1!;
      $title .= '_'.substr($name_path,0,2);
      if ($names{$name} ne $title) {
        print STDERR "Name missmatch: $name: $title :: $names{$name}\n";
      }
    }
  } elsif ($name =~ /\S/) {
print STDERR "Link to missing page: $name => $title\n"; #,join("\n", (sort keys %name_map)),"\n";
    $names{$name} = $title;
    $name_map{$title} = "MP:$name";
  } else { print STDERR "Empty link: $name $title\n"; }

#if (defined($names{$title})) { $title = $names{$title}; }
#else {print STDERR "Name? $title\n" } # $title =~ s!^.*/!!; 
  $title;
}

#sub tags {
#my ($href, $cont) = @_;
#  grep($$href{$1}++, $cont =~ /<\s*(\w+)/g);
#  grep($$href{$1}++, $cont =~ /<\s*(\/\w+)/g);
#}

sub perror {
my ($st, $t) = @_;
print STDERR "Error($st, $t)\n";
}
